#+title: Emacs configuration with Org Mode
#+author: Andrey Orst
#+email: andreyorst@gmail.com
#+setupfile: ~/.dotfiles/.org-defaults.org
#+startup: noinlineimages
#+property: header-args :tangle "~/.emacs.d/init.el"

[[file:.screenshot.png]]

This  is my  Emacs configuration  file written  as Org  document.  The
purpose of  this file  is to  learn basics  of Org  Mode and  Emacs in
general. I try  to keep my configuration simple and  fast and I mostly
use Emacs as environment for  studying LISP, currently Scheme, so this
configuration is pretty  much about it.  I'm not Emacs  Lisp guru yet,
so I  don't think  that this  document can  be really  interesting for
anyone.

I tend to  split my configurations of Editors to  sections.  The basic
sections are:

1. *[[*Common settings][Common settings]]* - configuration of basic editor facilities.
2. Custom commands  - which stores my custom commands  that I use. But
   since  in Emacs  everything is  a function,  the section  is called
   *[[*Functions][Functions]]*.
3. Language  specific  settings  - everything  that  needed  to  feel
   comfortable while  working with  some language.  In case  of Emacs,
   this section would be called *[[*Modes][Modes]]*.
4. Plugins - or *[[*Packages][Packages]]* to be precise, is the set of used plugins and
   it's configurations.

Since  Emacs  configuration and  Emacs  in  general is  more  complex,
compared to  [[https://github.com/andreyorst/dotfiles/tree/master/.config/nvim][Vim]], [[https://github.com/andreyorst/dotfiles/tree/master/.config/kak][Kakoune]],  and other editors,  there may  actually be
more sections, or  some may be missing completely. I  can't figure out
the best way  of splitting entire configuration with Org  mode so this
list may update or disappear if I'll realize that this isn't necessary
to have those sections.

Now on to the configuration itself.

* Init
I've  decided to  drop =org-babel-load-file=  usage, and  tangle current
file directly to main init file. This section represents the beginning
of =init.el=.

** Commentary
First of all, good init file starts with commentary:

#+BEGIN_SRC emacs-lisp
  ;;; init.el --- Emacs main configuration file
  ;;; Commentary:
  ;;; Emacs config by Andrey Orst
  ;;; Main config is located in .emacs.d/config.org
  ;;; This file contains some speed hacks taken from Doom Emacs
  ;;; Code:
#+END_SRC

Next I enable lexical binding to speedup load time:

#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t; -*-
#+END_SRC

** Garbage Collection and File Name Handler
I'm  declaring these  variables to  store default  values, to  restore
those after initialization is finished.

#+BEGIN_SRC emacs-lisp
  (defvar my--gc-cons-threshold gc-cons-threshold)
  (defvar my--gc-cons-percentage gc-cons-percentage)
  (defvar my--file-name-handler-alist file-name-handler-alist)
#+END_SRC

These settings help to avoid garbage collection during startup. The GC
eats up quite  a bit of time, easily doubling  startup time. The trick
is to turn up the memory threshold to prevent it from running:

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6
        message-log-max 16384
        auto-window-vscroll nil
        package-enable-at-startup nil
        file-name-handler-alist nil)
#+END_SRC

Let's define a hook to restore these values after startup is finished:

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook (lambda ()
                               (setq gc-cons-threshold my--gc-cons-threshold
                                     gc-cons-percentage my--gc-cons-percentage
                                     file-name-handler-alist my--file-name-handler-alist)))
#+END_SRC

** =Package.el=
I don't fully understand what the  following code does, but that's what
Doom  Emacs  uses  to  speedup  initialization,  so  I'll  include  it
anyways.  In  the  Doom  Emacs  Wiki  it  is  stated  that  Package.el
initialization is expensive.

#+BEGIN_SRC emacs-lisp
  (setq package-enable-at-startup nil
        package--init-file-ensured t)
#+END_SRC

** Load Path
Since  I've  started  splitting  configuration  into  separate  parts,
because  those  parts  don't  quite  match  the  literate  programming
paradigm, I want to be able to load those files:

#+BEGIN_SRC emacs-lisp
  (push (expand-file-name "lisp" user-emacs-directory) load-path)
#+END_SRC

* Common settings
This   section  is   all   about  basic   configurations  of   builtin
features. Emacs provides a lot of settings  on it's own, but I want to
stay  as  close   as  possible  to  the  defaults,   except  for  some
things. That's also answers why I don't  use Evil mode. If I wanted to
use Vim, I'd just used Vim.

** Startup
I  like to  keep my  starting process  straightforward, so  I tend  to
disable startup screen and start with the =*scratch*= buffer instead.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

I also  would like  to start  Emacs in  Org mode  by default,  so lets
change the default major mode for Emacs startup.

#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'org-mode)
#+END_SRC

And since scratch  buffer is no longer in  =lisp-interaction= mode, it's
better to change its message to something more /appropriate/ (nothing).

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message "")
#+END_SRC

** User Interface
These are some defaults for user  interface.  I don't like those bars,
buttons, tooltips, scrollbars, etc.

#+BEGIN_SRC emacs-lisp
  (ignore-errors
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (tooltip-mode -1)
    (fset 'menu-bar-open nil))
#+END_SRC

I'm using =ignore-errors=  here because I use both GUI  and TUI versions
of Emacs,  and since TUI version  doesn't have some of  those features
the startup process will fail.

Emacs uses weird method of naming a window, I'd like to see a file I'm
currently working  on in the task  bar in case my  Emacs was minimized
for some reason.

#+BEGIN_SRC emacs-lisp
  (setq-default frame-title-format '("%b — Emacs"))
#+END_SRC

*** Mode Line
Small  tweak to  mode line,  that disables  changing appearance  in non
active window.

#+BEGIN_SRC emacs-lisp
  (setq mode-line-in-non-selected-windows nil)
#+END_SRC

**** Line Numbers Column and Percent position
I  don't  find displaying  position  in  modeline really  great  idea,
because I need to move my eyes too much on big screen just to see what
line number I'm currently on.

#+BEGIN_SRC emacs-lisp
  (setq column-number-mode nil
        line-number-mode nil
        size-indication-mode nil
        mode-line-position nil)

#+END_SRC

** Font
I like this  Adobe Source Code Pro  font. Even if I use  Hack in every
other editor, for some reason I find this font just right for Emacs.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :font "Source Code Pro-10")
#+END_SRC

** Common Behaviors
I  don't like  how  Emacs  handles scrolling,  and  that  it uses  tab
characters by default.  I need tab  characters only when I work with C
code and Makefile rules.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                scroll-step 1
                scroll-conservatively 10000
                auto-window-vscroll nil
                scroll-margin 3)
#+END_SRC

** Input Languages
I use two keyboard layouts: =qwerty=  and =йцукен=, therefore I need a way
to switch between those without loosing  ability to use such chords as
=C-x=  which will  become  a =C-ч=  if  I select  Cyrillic  layout in  the
OS. Luckily for  me, Emacs provides a method to  switch layouts within
Emacs with =C-\=, so all common shortcuts will still work fine.

#+BEGIN_SRC emacs-lisp
  (setq default-input-method 'russian-computer)
#+END_SRC

I'm  not   using  =russian-jcuken=   here  because  it   represents  the
"typewriter" layout with number-line inverted,  so to access numbers I
need to use Shift key. =russian-computer= doesn't have this problem.

** Save History Between Sessions
This is what I've loved about Vim.

#+BEGIN_SRC emacs-lisp
  (savehist-mode 1)
#+END_SRC

** Matching Parentheses
One feature that I think  is really important, especially when working
with lisp code, is ability to  see matching bracket when cursor stands
near the other bracket. So I enable it for every programming language.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+END_SRC

** Fixing Dumb Emacs Stuff
This is just some fixes of things I found kind of strange.

*** Bell
I'm not  trying to  insult on anyone,  but usage of  the bell  is just
insane. It's  not 1980's, computers  have their own speakers  and rich
displays, why would anyone want  to use builtin speaker?  Why everyone
should know when I'm mistaken? Disable bell.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

*** Custom
I  don't like  custom,  and  especially would  like  to  stop it  from
interfering to  my configuration  files, so lets  move it  to separate
file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file :noerror)
#+END_SRC

*** Backups
I don't  know who decided  that having backups  all over the  place is
good idea, but I don't think alike.

#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t
        create-lockfiles nil
        backup-directory-alist '(("." . "~/.cache/emacs-backups"))
        auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups" t)))
#+END_SRC

*** Shorter Confirmation Dialogues
For some  reason in some  situations Emacs asks  for typing =yes=  or =no=
explicitly, instead of accepting =y= or =n=. This can be fixed with this.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Key Display Timeout
Emacs displays pressed  key after some time but it's  too fast for me,
because I use Emacs on the phone  too, and the keyboard is a bit small
for lightning fast typing.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook (lambda () (setq echo-keystrokes 3)))
#+END_SRC

** Trailing Whitespaces
I don't  want my files to  contain trailing whitespaces, so  this hook
will get rid of those automatically for me.

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** MELPA
Melpa is a  package repository, that I use to  get packages. Since all
packages that  I need can  be obtained  from there, I  didn't bothered
with different methods of installation.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC

Note for Windows users: change =https= to =http=

*** Package Initialization
This basic  piece of code  is used to  update package list  if there's
none.

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (when (not package-archive-contents)
    (package-refresh-contents))
#+END_SRC

* Functions
This section should contain functions that I've wrote for personal use
here and  there. I'm not  e-lisp expert, so code  may be not  the best
quality. If  you feel that this  code should be improved  you can open
issue and  blame on me  all you want. I  prefix functions with  =my/= to
avoid conflicts.

** =my/ensure-installed=
To ensure that  some essential packages are installed  I've wrote this
small lisp function that checks if package exists and if not downloads
it from Melpa.

#+BEGIN_SRC emacs-lisp
  (defun my/ensure-installed (package)
    "Ensure that PACKAGE is installed."
    (when (not (package-installed-p package))
      (package-install package)))
#+END_SRC

** =my/autokill-when-no-processes=
This function should be used as advice to any exit handle function

#+BEGIN_SRC emacs-lisp
  (defun my/autokill-when-no-processes (&rest _)
    "Kill buffer and its window automatically when there's no processes left."
    (when (null (get-buffer-process (current-buffer)))
        (kill-buffer (current-buffer))
        (delete-window)))
#+END_SRC

Let's define some advices with it. First, term buffer should be killed
when I exit terminal:

#+BEGIN_SRC emacs-lisp
  (advice-add 'term-handle-exit :after #'my/autokill-when-no-processes)
#+END_SRC

I'd also would like to do this for [[Geiser]] ([[https://gitlab.com/jaor/geiser/issues/267][it doesn't work for some reason]]):

** =my/org-update-inline-images=
This function is supposed to automatically update inline images in org
buffers, when for some reason image was changed.

#+BEGIN_SRC emacs-lisp
  (defun my/org-update-inline-images ()
    "Update inline images in Org-mode."
    (when org-inline-image-overlays
      (org-redisplay-inline-images)))
#+END_SRC

** =my/move-line-up=
This function moves current line  down. This is pretty common function
for most of editors, and sometimes I want to move lines around so this
will come in handy.

#+BEGIN_SRC emacs-lisp
  (defun my/move-line-up ()
    "Move up the current line."
    (interactive)
    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode))
#+END_SRC

Let's bind it to =M-p= or /Alt + p/.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-p") 'my/move-line-up)
  #+END_SRC

** =my/move-line-down=
The same as above but moves line down.

#+BEGIN_SRC emacs-lisp
  (defun my/move-line-down ()
    "Move down the current line."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode))
#+END_SRC

Let's bind it to =M-n= or /Alt + n/.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-n") 'my/move-line-down)
  #+END_SRC

** =my/org-tangle-on-config-save=
I often  edit my configuration,  so it would  be cool to  update Emacs
config automatically on save. This function will handle it:

#+BEGIN_SRC emacs-lisp
  (defun my/org-tangle-on-config-save ()
    "Tangle source code blocks when configuration file is saved."
    (when (string= buffer-file-name (file-truename "~/.emacs.d/config.org"))
      (org-babel-tangle)
      (byte-compile-file "~/.emacs.d/init.el")
      (load-file "~/.emacs.d/init.elc")))
#+END_SRC

To actually make it work we need to add this hook:

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-save-hook 'my/org-tangle-on-config-save)
#+END_SRC

** =my/set-frame-dark=
Emacs uses white titlebar, but since I'm using dark colorscheme I want
title bar to be dark as well. It is quite difficult to achieve this in
GNOME Shell, but I found this code [[https://nicolas.petton.fr/blog/emacs-dark-window-decoration.html][on the internet]]:

#+BEGIN_SRC emacs-lisp
  (defun my/set-frame-dark (&optional frame)
    "Set FRAME titlebar colorscheme to dark variant."
    (with-selected-frame (or frame (selected-frame))
    (call-process-shell-command (concat "xprop -f _GTK_THEME_VARIANT 8u -set _GTK_THEME_VARIANT \"dark\" -name \""
                                        (frame-parameter frame 'name)
                                        "\""))))
#+END_SRC

** =my/disable-fylcheck-in-org-src-bloc=
This function disables flycheck =emacs-lisp-checkdoc= messages.

#+BEGIN_SRC emacs-lisp
  (defun my/disable-fylcheck-in-org-src-block ()
    "Disable checkdoc in emacs-lisp buffers."
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC

** =my/escape=
Taken from [[https://www.reddit.com/r/emacs/comments/bb5c1w/weekly_tipstricketc_thread/ekgje7j/][u/clemera]] comment.

#+BEGIN_SRC emacs-lisp
  (defun my/escape ()
    "Quit in current context.

  When there is an active minibuffer and we are not inside it close
  it. When we are inside the minibuffer use the regular
  `minibuffer-keyboard-quit' which quits any active region before
  exiting. When there is no minibuffer `keyboard-quit' unless we
  are defining or executing a macro."
    (interactive)
    (cond ((active-minibuffer-window)
           (if (minibufferp)
               (minibuffer-keyboard-quit)
             (abort-recursive-edit)))
          (t
           ;; ignore top level quits for macros
           (unless (or defining-kbd-macro executing-kbd-macro)
             (keyboard-quit)))))
#+END_SRC

Let's remap default =keyboard-quit= key with this function.

#+BEGIN_SRC emacs-lisp
  (global-set-key [remap keyboard-quit] #'my/escape)
#+END_SRC

** =my/ansi-term-toggle=
This command toggles ansi-term window on and off without killing ansi-term.

#+BEGIN_SRC emacs-lisp
  (defun my/ansi-term-toggle ()
    "Toggle `ansi-term' window on and off with the same command."
    (interactive)
    (defvar my--ansi-term-name "ansi-term-popup")
    (defvar my--window-name (concat "*" my--ansi-term-name "*"))
    (cond ((get-buffer-window my--window-name)
           (delete-window
            (get-buffer-window my--window-name)))
          (t (split-window-below)
             (other-window 1)
             (cond ((get-buffer my--window-name)
                    (switch-to-buffer my--window-name))
                   (t (ansi-term "bash" my--ansi-term-name))))))
  #+END_SRC

I find it conveinient to bind this function to /Ctrl+t/ shortcut.

#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-t" 'my/ansi-term-toggle)
#+END_SRC

** =my/select-line=
This  command provides  a  nice  way to  create  region that  includes
current line.

#+BEGIN_SRC emacs-lisp
  (defun my/select-line ()
    "Select the current line."
    (interactive)
    (end-of-line)
    (set-mark (line-beginning-position)))
#+END_SRC

It is mapped to /Ctrl C/ + /x/ because in Kakoune selecting line is mapped
to /x/.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c x") 'my/select-line)
  #+END_SRC

* Modes
This section will contain some settings for various modes that are not
handled within package configurations.

** Org Mode
Org  Mode is  a great  mode for  taking notes,  managing to-do  lists,
writing books, literate programming, and  many other things. I primary
use it for taking notes on different programming languages, and manage
my Emacs configuration with it.

*** Startup Settings
For Org  Mode I  need spell  checking to be  enabled by  default. Also
Org-mode plays nicely with justification, so I'll set it to =full=, as I
think that it  is the most appropriate format for  text. Org files are
capable of displaying images, so let's enable them by default. There's
also  a nice  mode called  =org-indent-mode=  that makes  easier to  see
different sub-trees.  Speaking of sub-trees, =org-startup-folded= can be
set to ='content=, so every document will look like table of contents by
default. Last but not least, let's enable =auto-fill-mode= for org mode,
so all text will be folded  and re-filled after its length reaches the
=fill-column= value.  document

#+BEGIN_SRC emacs-lisp
  (require 'org)
  (add-hook 'org-mode-hook (lambda()
                             (flyspell-mode)
                             (setq default-justification 'full
                                   org-startup-with-inline-images t
                                   org-startup-folded 'content
                                   org-hide-emphasis-markers t
                                   org-highlight-latex-and-related '(latex)
                                   revert-without-query '(".*\.pdf"))
                             (auto-fill-mode)))
#+END_SRC

This will fontify code inside =SRC_BLOCK= sections:

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

*** Source Code Blocks
Since I'm using Emacs to configure Emacs, I want flycheck to run while
I'm editing =emacs-lisp= source blocks. But I find it distracting to see
warnings like =;;; Code=, so let's disable it:

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-src-mode-hook 'my/disable-fylcheck-in-org-src-block)
#+END_SRC

*** Inline Images
Since Org-mode allows inline images, we  need a way to update them, if
image  changes   for  some   reason.   We  will   use  hook   to  call
[[*=my/org-update-inline-images=][my/org-update-inline-images]] function after executing code with babel.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'my/org-update-inline-images)
#+END_SRC

**** Inline LaTeX Preview
Latex preview  feature is  really awesome, but  I don't  want produced
images to be stored in plain sight. At least use hidden folder.

#+BEGIN_SRC emacs-lisp
  (setq org-preview-latex-image-directory ".ltximg/")
#+END_SRC

*** Org Mappings
I don't like  that my =S-tab= mapping for  Company triggers =org-shifftab=
function, so I'll remap it to use =C-tab= instead.

#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map [backtab] nil)
  (define-key org-mode-map [S-iso-lefttab] nil)
  (define-key org-mode-map [C-tab] nil)
  (define-key org-mode-map [C-tab] 'org-shifttab)
#+END_SRC

*** Syntax Highlighting in Exported PDFs
To  highlight code  blocks  when  exporting to  LaTeX  we need  =minted=
package   installed   system-wide   and    this   code   (taken   from
[[https://emacs.stackexchange.com/questions/20839/exporting-code-blocks-to-pdf-via-latex/20841#20841][emacs.stackexchange.com]]):

#+BEGIN_SRC emacs-lisp
  (require 'ox-latex)
  (setq org-latex-listings 'minted)
#+END_SRC

Minted creates annoying directories  named =_minted-documentname=, and I
don't want  them to  be in plain  sight.  So this  code here  will put
those directories to temporary folder on my system.

#+BEGIN_SRC emacs-lisp
  (defvar minted-cache-dir
    (file-name-as-directory
     (expand-file-name ".minted/\\jombname"
                       temporary-file-directory)))

  (add-to-list 'org-latex-packages-alist
               `(,(concat "cachedir=" minted-cache-dir)
                 "minted" nil))
#+END_SRC

Now we need  to tell =pdflatex= to use these  escape sequence for proper
colors. This part is worth checking  for a more proper way of handling
highlighting, because right  now code blocks written  in language that
=minted= doesn't  support will  not be  exported to PDF  at all.   But I
don't know how to fix this.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

*** Cleanup After Export
Since I'm exporting my notes to PDF as final file format, I don't need
intermediary =.tex= file to stay.  Let's assume that these files are log
files, so Org mode will remove those after exporting is finished.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(add-to-list 'org-latex-logfiles-extensions "tex"))
#+END_SRC

This will get rid of =.tex= files.

*** Executable Languages
A nice feature of Org-mode over Markdown is that we can execute source
code  blocks with  a keybinding  and see  results inside  the document
itself.   Let's define  what languages  can be  executed with  =C-c C-c=
shortcut from org mode:

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((gnuplot . t)
     (scheme . t)))
#+END_SRC

And  to prevent  Emacs from  constantly asking  if I  want to  execute
source code, lets set =org-confirm-babel-evaluate= to =nil=

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

*** Paragraphs
I would like to use the same level headings after certain part, so all
my   deeply   nested   notes   contained   right   section   separator
headings. This is a hacky way but it works:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-classes
               '("article"
                 "\\documentclass{article}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
#+END_SRC

*** Markdown Export
I don't  think that I gonna  use this much,  but just in case  if I'll
ever decide to export Org to Markdown, I'll need this:

#+BEGIN_SRC emacs-lisp
  (require 'ox-md nil t)
#+END_SRC

** Flyspell Mode
It's annoying that if I save word to my personal dictionary, all other
misspelled  words  are no  longer  highlighted,  and  I need  to  call
=flyspell-buffer= again and again. Let's get rid of this.

#+BEGIN_SRC emacs-lisp
  (defun my/flyspell-buffer-after-pdict-save (&rest _)
    (flyspell-buffer))

  (advice-add 'ispell-pdict-save :after #'my/flyspell-buffer-after-pdict-save)
#+END_SRC

I've found  this trick [[https://www.reddit.com/r/emacs/comments/4oc7pg/spellcheck_flyspellmode_underlines_disappear_when/d5ptwql/][here]],  but I  don't really like  this solution,
since I don't  understand why I need to define  another function, that
simply calls =flyspell-buffer= but it works fine.

** Flycheck Mode
Flycheck  is useful  tool, which  can provide  syntax checking  on the
fly. Let's enable it for bunch of languages here.

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'flycheck-mode)
#+END_SRC

** Doc View Mode
Default resolution is too low:

#+BEGIN_SRC emacs-lisp
  (setq doc-view-resolution 192)
#+END_SRC

** Center View Mode
This is my own minor mode. It  makes text centered in the buffer where
the   mode   was   enabled.    I'm   aware   of   [[https://github.com/joostkremers/writeroom-mode][writeroom-mode]]   and
[[https://github.com/anler/centered-window-mode][centered-window-mode]],  but I  wanted to  try to  create my  own thing,
because there's no better way to learn a language, but to write in it.

#+BEGIN_SRC emacs-lisp
  (require 'center-view)
#+END_SRC

* Packages
Now that's  where fun  starts. I  try to  keep my  Emacs configuration
simple,  and  fast but  I  still  think  that  I need  some  essential
packages.

** Use Package
I use  package, named  =use-package= to install,  load and  configure my
packages.  I find this way very  consistent and easy to understand and
maintain.   Since   =use-package=  can't   install  itself,   let's  use
=my/ensure-installed=  function  for  it.   The only  thing  I  miss  is
updating  those packages,  but I  think  I'll come  up with  something
someday.

#+BEGIN_SRC emacs-lisp
  (my/ensure-installed 'use-package)
  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC

** Hydra
Hydra is  something like additional modes  for Emacs but it  isn't. It
allows me  to press some shortcut  and be locked in  a mode-like state
where keys  that are related to  this prefix shortcut are  behaving in
terms of this shortcut.

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :commands (hydra-default-pre
               hydra-keyboard-quit
               hydra--call-interactively-remap-maybe
               hydra-show-hint
               hydra-set-transient-map)
    :bind (("<f5>" . hydra-zoom/body))
    :config
    (defhydra hydra-zoom (:hint nil)
      "Scale text"
      ("+" text-scale-increase "in")
      ("-" text-scale-decrease "out")
      ("0" (text-scale-set 0) "reset")))
#+END_SRC

This  package will  be used  in many  other package  configurations to
provide sane keybindings.

** Doom Themes
I've  decided to  try out  Doom Themes.  It contains  nice variant  of
Atom-like One theme which I like, but it is also an amazingly well put
package, which defines colors for pretty much everything in Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :commands (doom-themes-org-config doom-themes-neotree-config)
    :init
    (load-theme 'doom-one t)
    (doom-themes-org-config)
    (doom-themes-neotree-config)
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)
    (let ((line (face-attribute 'mode-line :underline)))
      (set-face-attribute 'mode-line          nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :underline  line)
      (set-face-attribute 'mode-line          nil :box        nil)
      (set-face-attribute 'mode-line-inactive nil :box        nil)))
#+END_SRC

If  I  use =window-system=  I  want  [[*=my/set-frame-dark=][=my/set-frame-dark=]] to  run  during
initialization process, and when new frame is created.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (my/set-frame-dark)
    (add-hook 'after-make-frame-functions 'my/set-frame-dark :after))
#+END_SRC

** Solaire Mode
This  package helps  distinguish  buffers that  have  file opened  and
buffers that are for utilities like Neotree. Also it has cool name! =\[T]/=

#+BEGIN_SRC emacs-lisp
  (use-package solaire-mode
    :commands (solaire-global-mode solaire-mode-swap-bg)
    :hook
    ((change-major-mode after-revert ediff-prepare-buffer) . turn-on-solaire-mode)
    (minibuffer-setup . solaire-mode-in-minibuffer)
    :init
    (solaire-mode-swap-bg)
    (solaire-global-mode +1))
#+END_SRC

If only certain buffers could be so grossly incandescent.

** Neotree
I don't think that  I'm going to use it, but it  looks amazing so I've
installed it just for aesthetic purposes.

#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :bind (("<f8>" . neotree-toggle)))
#+END_SRC

** All The Icons
This  package provides  nice icons  for emacs  via custom  fonts. Just
don't forget to use =M-x all-the-icons-install-fonts RET= after install.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

** Markdown
Sometimes I need to edit Markdown documents, so this package is handy.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (defvar markdown-command "multimarkdown"))
#+END_SRC

For markdown  mode I would like  to have automatic spell  checking and
filling. Basically the same setup as for Org Mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook
            '(lambda()
               (flyspell-mode)
               (setq fill-column 80
                     default-justification 'left)
               (auto-fill-mode)))

#+END_SRC

** Geiser
Since I mostly use Emacs for studying LISP, and I'm reading SICP which
uses Scheme as main LISP flavor for explanations and exercises, I need
a tool  to run Scheme,  and Geiser seems  like the most  viable option
here, since it also provides completion for it.

#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :config
    (add-hook 'scheme-mode-hook 'geiser-mode)
    (advice-add 'geiser-repl-exit :after #'my/autokill-when-no-processes)
    :init
    (setq geiser-active-implementations '(guile)
          geiser-default-implementation 'guile))
#+END_SRC

** Parinfer
Now that's a quality package. It makes writing LISP so easy, that I've
never thought it could be.

There's  a lot  of configuration  here, but  it was  taken as  is from
Parinfer Mode repository.

#+BEGIN_SRC emacs-lisp
  (use-package parinfer
    :commands parinfer-mode
    :bind
    (("C-," . parinfer-toggle-mode))
    :init
    (progn
      (setq parinfer-extensions
            '(defaults
               pretty-parens
               smart-tab
               smart-yank))
      (add-hook 'clojure-mode-hook #'parinfer-mode)
      (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
      (add-hook 'common-lisp-mode-hook #'parinfer-mode)
      (add-hook 'scheme-mode-hook #'parinfer-mode)
      (add-hook 'lisp-mode-hook #'parinfer-mode)))
#+END_SRC

** Flx
This package provides some kind of fuzzy matching for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package flx)
#+END_SRC

** Ivy and Counsel
Ivy  is a  narrowing  framework  like Helm,  but  much  lighter in  my
experience.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :commands ivy-mode
    :init
    (setq ivy-use-virtual-buffers t
          enable-recursive-minibuffers t)
    :bind (("C-x C-b" . ivy-switch-buffer)
           ("C-x b" . ivy-switch-buffer))
    :config
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy))
          ivy-count-format ""
          ivy-display-style nil
          ivy-minibuffer-faces nil)
    (ivy-mode 1))
#+END_SRC

It integrates with  Counsel that handles minibuffer,  so let's install
it too.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind (("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("C-h f" . counsel-describe-function)
           ("C-h v" . counsel-describe-variable)
           ("C-h l" . counsel-find-library)))
#+END_SRC

** Flycheck
A really  nice linting package that  helps me track errors  in most of
languages.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck)
#+END_SRC

** Company
Complete anything framework. Nothing much to say. Does it's job.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :bind (:map company-active-map
                ("TAB" . company-complete-common-or-cycle)
                ("<tab>" . company-complete-common-or-cycle)
                ("<S-Tab>" . company-select-previous)
                ("<backtab>" . company-select-previous))
    :init
    (add-hook 'after-init-hook 'global-company-mode)
    (setq company-require-match 'never
          company-minimum-prefix-length 3
          company-tooltip-align-annotations t
          company-frontends
          '(company-pseudo-tooltip-unless-just-one-frontend
            company-preview-frontend
            company-echo-metadata-frontend))
    :config
    (setq company-backends (remove 'company-clang company-backends)
          company-backends (remove 'company-xcode company-backends)
          company-backends (remove 'company-cmake company-backends)
          company-backends (remove 'company-gtags company-backends)))
#+END_SRC

** Undo Tree
This is more familiar  undo mode. It adds =C-/= mapping  to undo and =C-?=
mapping to redo.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :commands global-undo-tree-mode
    :init
    (global-undo-tree-mode 1))
#+END_SRC

** Yasnippet
Another very handy package, that helps insert templates of code. Now I
really need to write some snippets to use...

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :commands yas-reload-all
    :init (yas-reload-all))
#+END_SRC

** Projectile
Since Emacs  is stupid, it  changes working directory to  current file
location. So I need a whole plugin to workaround this silly issue.

However this plugin is quite useful with Git repositories.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :commands projectile-mode
    :bind (("C-c p" . projectile-command-map))
    :init
    (projectile-mode +1)
    (setq projectile-svn-command "fd -L --type f --print0"
          projectile-generic-command "fd -L --type f --print0"
          projectile-completion-system 'ivy))
#+END_SRC

*** Counsel projectile
It makes using projectile easier by allowing fuzzy matching.

#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :commands counsel-projectile-mode
    :config (counsel-projectile-mode))
#+END_SRC

** GNU Plot
This is a  package needed for making plots with  gnuplot.  Required by
Org mode.

#+BEGIN_SRC emacs-lisp
  (use-package gnuplot)
#+END_SRC

** Rust
I'd like to  have Rust syntax highlighting and  some basic facilities,
since I'm  planning to write my  exercises in org mode.   Since I make
notes in Org-mode, and  I started to use it for Rust  too, I need some
settings for Rust mode.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :config (add-hook 'rust-mode-hook
                      '(lambda()
                         (racer-mode)
                         (yas-minor-mode)
                         (electric-pair-mode)
                         (setq company-tooltip-align-annotations t))))
#+END_SRC

*** Racer
A  Rust  Auto-Complete-er  package  support.   It's  kinda  slow,  but
whatever.

#+BEGIN_SRC emacs-lisp
  (use-package racer
    :config (add-hook 'racer-mode-hook #'eldoc-mode))
#+END_SRC

** TOML
=toml-mode= helps  with highlighting of  TOML files, which Rust  uses to
configure project.

#+BEGIN_SRC emacs-lisp
  (use-package toml-mode)
#+END_SRC

** EditorConfig
Speaking  of formatting,  =.editorconfig= file  provides a  nice way  to
synchronize my editor configurations between projects.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :commands editorconfig-mode
    :config
    (editorconfig-mode 1))
#+END_SRC

** Magit
Magit is a Emacs  interface to Git.  I've heard that  it has many nice
features, so I want to try it out.

#+BEGIN_SRC emacs-lisp
  (use-package magit)
#+END_SRC

** Vdiff
=vdiff= is a package, that works similar to Vimdiff.  Ediff isn't really
comfortable to  use, and vdiff also  has integration with [[*Magit][Magit]],  so I
gonna try it out.

#+BEGIN_SRC emacs-lisp
  (use-package vdiff
    :bind (:map vdiff-mode-map
                ("C-c" . vdiff-mode-prefix-map))
    :init (setq vdiff-lock-scrolling t
                vdiff-diff-algorithm 'diff
                vdiff-disable-folding nil
                vdiff-min-fold-size 4
                vdiff-subtraction-style 'full
                vdiff-subtraction-fill-char ?\ )
    :config
    (set-face-attribute 'vdiff-subtraction-face nil :background "#553333" :foreground "#cc99999")
    (set-face-attribute 'vdiff-addition-face nil :background "#335533" :foreground "#cceecc")
    (set-face-attribute 'vdiff-change-face nil :background "#293239" :foreground "#4f97d7")
    (add-hook 'vdiff-mode-hook #'outline-show-all))
#+END_SRC

*** Vdiff Magit
=vdiff-magit= is  a supplement  package, that provides  integration with
[[*Magit][Magit]] package.

#+BEGIN_SRC emacs-lisp
  (use-package vdiff-magit
    :commands (vdiff-magit-dwim vdiff-magit)
    :bind (:map magit-mode-map
                ("e" . 'vdiff-magit-dwim)
                ("E" . 'vdiff-magit))
    :init
    (setq vdiff-magit-stage-is-2way t)
    :config
    (transient-suffix-put 'magit-dispatch "e" :description "vdiff (dwim)")
    (transient-suffix-put 'magit-dispatch "e" :command 'vdiff-magit-dwim)
    (transient-suffix-put 'magit-dispatch "E" :description "vdiff")
    (transient-suffix-put 'magit-dispatch "E" :command 'vdiff-magit))
#+END_SRC

** Which Key
=which-key=  is a  package that  can show  all possible  completions for
keyboard shortcuts in a popup menu. I'm still learning Emacs, so let's
enable it by default.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :commands which-key-mode
    :init
    (which-key-mode))
#+END_SRC

** Multiple Cursors
This  package provides  multiple cursors  functionality to  Emacs.  It
isn't much like Kakoune's multiple selections, but anything will do. I
guess I'll figure out best mappings over time.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind (("C-S-<mouse-1>" . mc/add-cursor-on-click)
           ("C-c m" . hydra-mc/body))
    :config (defhydra hydra-mc (:hint nil)
              "
  ^Select^               ^Discard^                   ^Move^
  ^──────^───────────────^───────^───────────────────^────^────────────
  _M-s_ split lines      _M-SPC_ discard current     _&_ align
  _s_   select regexp    _b_     discard blank lines _(_ cycle backward
  _n_   select next      _d_     remove duplicated   _)_ cycle forward
  _p_   select previous  _q_     exit                ^ ^
  _C_   select next line"
              ("M-s" mc/edit-ends-of-lines)
              ("s" mc/mark-all-in-region-regexp)
              ("n" mc/mark-next-like-this-word)
              ("p" mc/mark-previous-like-this-word)
              ("&" mc/vertical-align-with-space)
              ("(" mc/cycle-backward)
              (")" mc/cycle-forward)
              ("M-SPC" mc/remove-current-cursor)
              ("b" mc/remove-cursors-on-blank-lines)
              ("d" mc/remove-duplicated-cursors)
              ("C" mc/mark-next-lines)
              ("q" mc/remove-duplicated-cursors :exit t)))
#+END_SRC

*** MC Extras
this package provides  some extra functions for  multiple cursors. I'm
interested in  =mc/remove-duplicaded-cursors=. When using [[*Phi  Search][Phi Search]] it
often  places several  cursors at  the same  positions, which  I don't
like.

#+BEGIN_SRC emacs-lisp
  (use-package mc-extras
    :config
    (advice-add 'phi-search :after 'mc/remove-duplicated-cursors))
#+END_SRC

** Expand Region
This package allows to expand  or reduce region selection semantically
in most languages that I work with inside Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :commands (er/expand-region
               er/mark-paragraph
               er/mark-inside-pairs
               er/mark-outside-pairs
               er/mark-inside-quotes
               er/mark-outside-quotes
               er/contract-region)
    :bind (("C-c e" . hydra-er/body))
    :config (defhydra hydra-er (:hint nil)
              "
  ^Expand^          ^Mark^
  ^──────^──────────^────^─────────────────
  _e_ expand region _(_ inside pairs
  _-_ reduce region _)_ around pairs
  ^ ^               _q_ inside quotes
  ^ ^               _Q_ around quotes
  ^ ^               _p_ paragraph"
              ("e" er/expand-region :post hydra-er/body)
              ("-" er/contract-region :post hydra-er/body)
              ("p" er/mark-paragraph)
              ("(" er/mark-inside-pairs)
              (")" er/mark-outside-pairs)
              ("q" er/mark-inside-quotes)
              ("Q" er/mark-outside-quotes)))
#+END_SRC

** Phi Search
This search mode is compatible with multiple cursors.

#+BEGIN_SRC emacs-lisp
  (use-package phi-search
    :bind (("C-s" . phi-search)
           ("C-r" . phi-search-backward)))
#+END_SRC

** Eyebrowse
This  package imitates  virtual workspaces,  or virtual  frames inside
single Emacs  frame. This  is really  useful, when  you have  bunch of
windows, and you  want to open new  set but don't want  to loose other
window configurations. It works much like Vim tabs, or Tmux windows.

#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :commands eyebrowse-mode
    :init
    (eyebrowse-mode t))
#+END_SRC

** Moody
This is a mode line for Emacs  that looks like default but prettier. I
like it, and it doesn't add too much overhead.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (use-package moody
      :commands (moody-replace-mode-line-buffer-identification
                 moody-replace-vc-mode)
      :init
      (setq-default x-underline-at-descent-line t)
      (moody-replace-mode-line-buffer-identification)
      (moody-replace-vc-mode)))
#+END_SRC

** Minions
This  package  implements   a  menu  that  lists   all  enabled  minor
modes. Emacs mode  line can become pretty long, so  this can be handy,
and perhaps I don't need to use =:diminish= everywhere anymore.

#+BEGIN_SRC emacs-lisp
  (use-package minions
    :commands minions-mode
    :config (setq minions-direct '(multiple-cursors-mode
                                   flycheck-mode
                                   flyspell-mode
                                   parinfer-mode))
    :init (minions-mode 1))
#+END_SRC

* Postscript
This Emacs Configuration features various  cool E-Lisp hacks that I've
found  in the  Internet,  and I  try to  keep  references to  original
places, so reader  could refer to those, because I  alter these pieces
of code for my  personal needs and thus it may  not be compatible with
other people tastes, and because I want to credit original author.

If you  find any issue with  my config feel  free to [[https://github.com/andreyorst/dotfiles/issues/new][file an  issue]] or
contact me via email: [[mailto:andreyorst@gmail.com][andreyorst@gmail.com]].

And as a final step of a proper init file:

#+BEGIN_SRC emacs-lisp
  (provide 'init)
  ;;; init.el ends here
#+END_SRC

Thanks for reading!
